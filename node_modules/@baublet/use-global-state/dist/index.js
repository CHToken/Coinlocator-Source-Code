"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = require("react");
var keys = {}, createCentralDispatcher = function (key) { return function (value) {
    keys[key].value = value;
    keys[key].dispatchers.forEach(function (dispatcher) { return dispatcher && dispatcher(value); });
}; };
// This resets the dispatchers arrays on keys that all null, indicating
// that the components that use this global state have been all unmounted
// We don't want to leave around a bunch of arrays that are just stuffed
// full of null values. For long-running applications, this can be
// memory intensive. We trade a tiny bit of up-front performance here for
// better long-term memory management.
function resetEmptyKeys() {
    Object.keys(keys).forEach(function (key) {
        var allNull = true;
        keys[key].dispatchers.forEach(function (dispatcher) {
            if (!allNull)
                return;
            if (dispatcher !== null) {
                allNull = false;
            }
        });
        if (allNull) {
            keys[key].dispatchers = [];
        }
    });
}
function useGlobalState(key, initialState) {
    if (initialState === void 0) { initialState = ""; }
    // Some basic cleaning
    resetEmptyKeys();
    var _a = react_1.useState(initialState), state = _a[0], dispatcher = _a[1];
    if (!keys[key]) {
        keys[key] = {
            value: initialState,
            centralDispatcher: createCentralDispatcher(key),
            dispatchers: []
        };
    }
    react_1.useEffect(function () {
        var index = keys[key].dispatchers.push(dispatcher) - 1;
        return function () {
            keys[key].dispatchers[index] = null;
        };
    }, []);
    var value = keys[key] && keys[key].value ? keys[key].value : state;
    return [value, keys[key].centralDispatcher];
}
exports.useGlobalState = useGlobalState;
//# sourceMappingURL=index.js.map